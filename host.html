<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üé¨ SyncFlix Host - LIVE</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Arial, sans-serif;
      }
      body {
        background: #000;
        color: white;
        padding: 20px;
      }

      .container {
        max-width: 1000px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }
      h1 {
        color: #4caf50;
      }

      .room-id {
        background: #222;
        padding: 15px;
        border-radius: 10px;
        font-family: monospace;
        font-size: 24px;
        letter-spacing: 3px;
        margin: 20px auto;
        max-width: 400px;
        border: 2px solid #4caf50;
        text-align: center;
      }

      .main-content {
        display: flex;
        gap: 30px;
        margin-bottom: 30px;
      }

      @media (max-width: 768px) {
        .main-content {
          flex-direction: column;
        }
      }

      .video-section {
        flex: 2;
      }

      .video-container {
        background: #111;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        min-height: 400px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #localVideo {
        max-width: 100%;
        max-height: 500px;
        border-radius: 5px;
        background: #000;
      }

      .no-video {
        text-align: center;
        color: #888;
      }

      .controls {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
      }

      .btn {
        flex: 1;
        padding: 15px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
      }

      .btn-start {
        background: #4caf50;
        color: white;
      }

      .btn-stop {
        background: #f44336;
        color: white;
      }

      .btn:disabled {
        background: #666;
        cursor: not-allowed;
        opacity: 0.7;
      }

      .sidebar {
        flex: 1;
        min-width: 300px;
      }

      .panel {
        background: #111;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
      }

      .panel h3 {
        color: #4caf50;
        margin-bottom: 15px;
      }

      .connection-status {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
      }

      .status-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #f44336;
      }

      .status-dot.connected {
        background: #4caf50;
        box-shadow: 0 0 15px #4caf50;
      }

      .chat-messages {
        height: 300px;
        overflow-y: auto;
        background: #000;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 15px;
      }

      .message {
        margin-bottom: 10px;
        padding: 10px 15px;
        border-radius: 10px;
        max-width: 90%;
        word-wrap: break-word;
      }

      .message.sent {
        background: #4caf50;
        margin-left: auto;
        margin-right: 10px;
      }

      .message.received {
        background: #333;
        margin-right: auto;
        margin-left: 10px;
      }

      .message.system {
        background: #ff9800;
        color: #000;
        text-align: center;
        margin: 5px auto;
        padding: 8px 12px;
        font-size: 14px;
      }

      .chat-input {
        display: flex;
        gap: 10px;
      }

      .chat-input input {
        flex: 1;
        padding: 12px;
        background: #222;
        border: 1px solid #444;
        border-radius: 5px;
        color: white;
        font-size: 16px;
      }

      .chat-input button {
        padding: 12px 25px;
        background: #4caf50;
        border: none;
        border-radius: 5px;
        color: white;
        cursor: pointer;
        font-weight: bold;
      }

      .notification {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: #333;
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        gap: 12px;
        transform: translateX(150%);
        transition: transform 0.3s;
        z-index: 1000;
        max-width: 400px;
      }

      .notification.show {
        transform: translateX(0);
      }

      .notification.success {
        background: #4caf50;
      }

      .notification.error {
        background: #f44336;
      }

      /* Scrollbar */
      .chat-messages::-webkit-scrollbar {
        width: 8px;
      }

      .chat-messages::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
      }

      .chat-messages::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üé¨ SyncFlix Host - LIVE</h1>
        <p>Share your screen with partner - REAL WebRTC</p>
      </div>

      <div class="room-id" id="roomIdDisplay">Connecting to server...</div>

      <div class="main-content">
        <div class="video-section">
          <div class="video-container">
            <video id="localVideo" autoplay playsinline muted></video>
            <div class="no-video" id="noVideo">
              <div>üñ•Ô∏è Ready to Share Screen</div>
              <p>Click "Start Sharing" below</p>
            </div>
          </div>

          <div class="controls">
            <button id="startBtn" class="btn btn-start">
              Start Screen Sharing
            </button>
            <button id="stopBtn" class="btn btn-stop" disabled>
              Stop Sharing
            </button>
          </div>
        </div>

        <div class="sidebar">
          <div class="panel">
            <h3>üîó Connection</h3>
            <div class="connection-status">
              <div class="status-dot" id="statusDot"></div>
              <span id="statusText">Connecting to server...</span>
            </div>
            <p>Share this Room ID with partner:</p>
            <div
              style="
                background: #000;
                padding: 10px;
                border-radius: 5px;
                margin: 10px 0;
                font-family: monospace;
                text-align: center;
                font-size: 20px;
              "
            >
              <span id="roomCode">-----</span>
            </div>
          </div>

          <div class="panel">
            <h3>üí¨ Live Chat</h3>
            <div class="chat-messages" id="chatMessages">
              <div class="message system">Setting up connection...</div>
            </div>
            <div class="chat-input">
              <input
                type="text"
                id="chatInput"
                placeholder="Type a message..."
                disabled
              />
              <button id="sendBtn" disabled>Send</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="notification" id="notification">
      <span id="notificationText">Ready</span>
    </div>

    <!-- Simple Peer for WebRTC -->
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.0/simplepeer.min.js"></script>

    <script>
      // REAL WebRTC Host
      const roomId = generateRoomId();
      let socket = null;
      let peer = null;
      let localStream = null;
      let dataChannel = null;
      let viewerConnected = false;

      // Initialize
      initializeApp();

      function initializeApp() {
        // Connect to WebSocket server
        connectWebSocket();

        // Display room ID
        document.getElementById("roomIdDisplay").textContent =
          `Room ID: ${roomId}`;
        document.getElementById("roomCode").textContent = roomId;

        addSystemMessage(`Your Room ID: ${roomId}`);
        addSystemMessage("Share this ID with your partner");

        // Event listeners
        document
          .getElementById("startBtn")
          .addEventListener("click", startScreenSharing);
        document
          .getElementById("stopBtn")
          .addEventListener("click", stopScreenSharing);
        document
          .getElementById("sendBtn")
          .addEventListener("click", sendMessage);
        document
          .getElementById("chatInput")
          .addEventListener("keypress", function (e) {
            if (e.key === "Enter") sendMessage();
          });
      }

      function generateRoomId() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let result = "";
        for (let i = 0; i < 6; i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }

      function connectWebSocket() {
        // ‚úÖ FIXED: Use wss:// not https://
        const wsUrl = `wss://syncflix-r5ak.onrender.com/ws?room=${roomId}&username=Host`;
        console.log("Connecting to:", wsUrl);

        socket = new WebSocket(wsUrl);

        socket.onopen = () => {
          console.log("‚úÖ Connected to signaling server");
          showNotification("Connected to server");
          updateStatus("Waiting for partner...");

          // Join room as host
          socket.send(
            JSON.stringify({
              type: "join",
              room: roomId,
              role: "host",
            }),
          );
        };

        socket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log("üì® Received:", data.type, data);

            switch (data.type) {
              case "joined":
                addSystemMessage(`Joined room ${roomId}`);
                break;

              case "user_joined":
                if (data.role === "viewer") {
                  addSystemMessage(`üë§ Viewer connected: ${data.username}`);
                  showNotification("Viewer connected!");
                  updateStatus("Viewer connected");
                  viewerConnected = true;

                  console.log(
                    `üë§ Viewer ${data.username} joined room ${roomId}`,
                  );

                  // If we're already sharing, start WebRTC
                  if (localStream) {
                    console.log(
                      "üé¨ Starting WebRTC because viewer joined and we have stream",
                    );
                    startWebRTC();
                  } else {
                    console.log(
                      "‚è≥ Waiting for host to start screen sharing...",
                    );
                    addSystemMessage('Click "Start Sharing" to begin');
                  }
                }
                break;

              case "user_left":
                if (data.role === "viewer") {
                  addSystemMessage(`üë§ Viewer disconnected`);
                  showNotification("Viewer disconnected");
                  updateStatus("Waiting for partner...");
                  viewerConnected = false;

                  if (peer) {
                    peer.destroy();
                    peer = null;
                  }
                  disableChat();
                }
                break;

              case "answer":
                console.log("üì° Received WebRTC answer from viewer");
                if (peer) {
                  peer.signal(data.answer);
                }
                break;

              case "candidate":
                console.log("üì° Received ICE candidate");
                if (peer) {
                  peer.signal(data.candidate);
                }
                break;

              case "chat":
                addReceivedMessage(
                  `${data.username}: ${data.text || data.message}`,
                );
                break;
            }
          } catch (error) {
            console.error("Error parsing message:", error);
          }
        };

        socket.onerror = (error) => {
          console.error("WebSocket error:", error);
          showNotification("Connection error", "error");
          updateStatus("Connection error");
        };

        socket.onclose = () => {
          console.log("WebSocket closed");
          showNotification("Disconnected from server", "error");
          updateStatus("Disconnected");

          // Try to reconnect after 5 seconds
          setTimeout(() => {
            connectWebSocket();
          }, 5000);
        };
      }

      async function startScreenSharing() {
        try {
          // Get screen with audio
          localStream = await navigator.mediaDevices.getDisplayMedia({
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
              frameRate: { ideal: 30 },
            },
            audio: true,
          });

          console.log("üé¨ Screen sharing started:", localStream);
          console.log(
            "Tracks:",
            localStream.getTracks().map((t) => t.kind),
          );

          // Function to check and start WebRTC automatically


          function checkAndStartWebRTC() {
              console.log('üîÑ Checking if WebRTC should start...');
              console.log('  - Local stream:', localStream ? 'Yes' : 'No');
              console.log('  - Viewer connected:', viewerConnected);
              console.log('  - Peer already exists:', peer ? 'Yes' : 'No');

              if (localStream && viewerConnected && !peer) {
                  console.log('‚úÖ All conditions met! Starting WebRTC...');
                   startWebRTC();
                    return true;
               }
             return false;
           }

           // Call this whenever viewer connects
            // Update the user_joined case in socket.onmessage:

          // Show local video
          document.getElementById("localVideo").srcObject = localStream;
          document.getElementById("noVideo").style.display = "none";

          // Update UI
          document.getElementById("startBtn").disabled = true;
          document.getElementById("stopBtn").disabled = false;

          addSystemMessage("‚úÖ Screen sharing started");
          showNotification("Screen sharing active");

          // Start WebRTC if viewer is already connected
          setTimeout(() => {
            if (viewerConnected) {
              console.log("üé¨ Viewer is already connected, starting WebRTC...");
              startWebRTC();
            } else {
              console.log("‚è≥ Waiting for viewer to connect...");
              addSystemMessage("‚è≥ Waiting for viewer to connect...");

              // Listen for viewer connection
              const checkViewerInterval = setInterval(() => {
                if (viewerConnected) {
                  console.log("‚úÖ Viewer connected! Starting WebRTC...");
                  startWebRTC();
                  clearInterval(checkViewerInterval);
                }
              }, 1000);

              // Stop checking after 30 seconds
              setTimeout(() => {
                clearInterval(checkViewerInterval);
                if (!viewerConnected) {
                  addSystemMessage(
                    "‚è∞ No viewer connected yet. Share Room ID: " + roomId,
                  );
                }
              }, 30000);
            }
          }, 500);
          // Handle when user stops sharing via browser UI
          localStream.getVideoTracks()[0].onended = () => {
            console.log("Screen sharing stopped by browser");
            stopScreenSharing();
            showNotification("Screen sharing stopped by browser");
          };
        } catch (error) {
          console.error("Screen sharing error:", error);
          addSystemMessage(`‚ùå Error: ${error.message}`);
          showNotification("Failed to share screen", "error");
        }
      }

      function stopScreenSharing() {
        console.log("üõë Stopping screen sharing");

        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localStream = null;
        }

        if (peer) {
          peer.destroy();
          peer = null;
        }

        // Update UI
        document.getElementById("localVideo").srcObject = null;
        document.getElementById("noVideo").style.display = "block";
        document.getElementById("startBtn").disabled = false;
        document.getElementById("stopBtn").disabled = true;

        disableChat();
        addSystemMessage("üõë Screen sharing stopped");
        showNotification("Screen sharing stopped");
      }

      function startWebRTC() {
        if (!localStream) {
          console.error("‚ùå No local stream to share");
          return;
        }

        console.log("üåê Starting WebRTC connection...");
        console.log(
          "Local stream tracks:",
          localStream.getTracks().map((t) => t.kind),
        );

        // Destroy existing peer if any
        if (peer) {
          console.log("Destroying existing peer");
          peer.destroy();
          peer = null;
        }

        // Create SimplePeer instance with TURN servers
        peer = new SimplePeer({
          initiator: true,
          stream: localStream,
          trickle: true,
          config: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              {
                urls: "turn:numb.viagenie.ca:3478",
                credential: "muazkh",
                username: "webrtc@live.com",
              },
              {
                urls: "turn:openrelay.metered.ca:80",
                username: "openrelayproject",
                credential: "openrelayproject",
              },
            ],
          },
          // Add these options for better compatibility
          offerConstraints: {
            offerToReceiveAudio: true,
            offerToReceiveVideo: true,
          },
          sdpTransform: (sdp) => {
            // Modify SDP for better compatibility
            return sdp.replace(
              /a=mid:video\r\n/g,
              "a=mid:video\r\nb=AS:2000\r\n",
            );
          },
        });

        console.log("üéØ WebRTC peer created, waiting for signal...");

        // Handle signaling data - CRITICAL: This sends the offer
        peer.on("signal", (data) => {
          console.log("üì§ WebRTC signal event:", data.type);
          console.log("Signal data:", data);

          if (socket && socket.readyState === WebSocket.OPEN) {
            if (data.type === "offer") {
              console.log("üì§ SENDING WebRTC offer to server...");
              console.log(
                "Offer SDP (first 200 chars):",
                data.sdp.substring(0, 200),
              );

              socket.send(
                JSON.stringify({
                  type: "offer",
                  room: roomId,
                  offer: data,
                  timestamp: Date.now(),
                }),
              );

              addSystemMessage("üì§ Sent WebRTC offer to viewer");
              showNotification("Sending WebRTC offer...");
            } else if (data.candidate) {
              console.log("üì§ Sending ICE candidate");
              socket.send(
                JSON.stringify({
                  type: "candidate",
                  room: roomId,
                  candidate: data,
                }),
              );
            }
          } else {
            console.error(
              "‚ùå Cannot send signal - WebSocket not open:",
              socket ? socket.readyState : "no socket",
            );
          }
        });

        // WebRTC connected
        peer.on("connect", () => {
          console.log("‚úÖ WebRTC CONNECTED to viewer!");
          addSystemMessage("‚úÖ WebRTC connection established");
          showNotification("WebRTC connected!");
          enableChat();

          // Send test message via data channel
          setTimeout(() => {
            if (peer.connected) {
              try {
                peer.send(
                  JSON.stringify({
                    type: "chat",
                    text: "Host: WebRTC connected!",
                    timestamp: Date.now(),
                  }),
                );
                console.log("‚úÖ Test message sent via data channel");
              } catch (error) {
                console.error("Failed to send test message:", error);
              }
            }
          }, 1000);
        });

        // Stream event (should not happen for initiator)
        peer.on("stream", (stream) => {
          console.log("üé¨ Received remote stream (unexpected for host)");
        });

        // Handle data channel for chat
        peer.on("data", (data) => {
          try {
            const message = JSON.parse(data.toString());
            console.log("üì® Received data channel message:", message);
            if (message.type === "chat") {
              addReceivedMessage(message.text);
            }
          } catch (error) {
            console.error("Error parsing data channel message:", error);
          }
        });

        // Handle errors
        peer.on("error", (error) => {
          console.error("‚ùå WebRTC ERROR:", error);
          console.error("Error name:", error.name);
          console.error("Error message:", error.message);
          addSystemMessage(`‚ùå WebRTC error: ${error.message}`);
          showNotification("WebRTC connection failed", "error");
        });

        // Handle close
        peer.on("close", () => {
          console.log("üîå WebRTC connection closed");
          disableChat();
          addSystemMessage("üîå WebRTC connection closed");
        });

        // Force offer creation after a short delay
        setTimeout(() => {
          if (peer && !peer.destroyed) {
            console.log("‚è∞ Timeout - checking peer state");
            console.log("Peer destroyed:", peer.destroyed);
            console.log("Peer connected:", peer.connected);

            // Manually trigger offer if not already created
            if (!peer._pc || peer._pc.signalingState === "stable") {
              console.log("üîÑ Manually checking for offer...");
            }
          }
        }, 1000);
      }

      function sendViaWebSocket(message) {
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(
            JSON.stringify({
              type: "chat",
              room: roomId,
              message: message,
            }),
          );

          addSentMessage(message);
          document.getElementById("chatInput").value = "";
        }
      }

      function enableChat() {
        document.getElementById("chatInput").disabled = false;
        document.getElementById("sendBtn").disabled = false;
        document.getElementById("chatInput").placeholder =
          "Chat with viewer...";
        document.getElementById("chatInput").focus();
      }

      function disableChat() {
        document.getElementById("chatInput").disabled = true;
        document.getElementById("sendBtn").disabled = true;
        document.getElementById("chatInput").placeholder = "Not connected...";
      }

      function updateStatus(text) {
        document.getElementById("statusText").textContent = text;

        if (text.includes("connected")) {
          document.getElementById("statusDot").className =
            "status-dot connected";
        } else {
          document.getElementById("statusDot").className = "status-dot";
        }
      }

      function addSystemMessage(text) {
        addMessage(text, "system");
      }

      function addSentMessage(text) {
        addMessage(`You: ${text}`, "sent");
      }

      function addReceivedMessage(text) {
        addMessage(`Viewer: ${text}`, "received");
      }

      function addMessage(text, type) {
        const chat = document.getElementById("chatMessages");
        const msg = document.createElement("div");
        msg.className = `message ${type}`;
        msg.textContent = text;
        chat.appendChild(msg);
        chat.scrollTop = chat.scrollHeight;
      }

      function showNotification(text, type = "success") {
        const notification = document.getElementById("notification");
        document.getElementById("notificationText").textContent = text;
        notification.className = `notification ${type} show`;

        setTimeout(() => {
          notification.classList.remove("show");
        }, 3000);
      }
    </script>
  </body>
</html>
