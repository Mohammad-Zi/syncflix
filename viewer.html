<!DOCTYPE html>
<html>
<head>
    <title>SyncFlix - WebRTC Screen Sharing</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #container { display: flex; flex-wrap: wrap; gap: 20px; }
        .video-container { width: 400px; border: 2px solid #ccc; padding: 10px; }
        video { width: 100%; background: #000; }
        .controls { margin: 10px 0; }
        button { margin: 5px; padding: 8px 16px; cursor: pointer; }
        .status { padding: 10px; margin: 5px 0; border-radius: 5px; }
        .connected { background: #d4edda; }
        .disconnected { background: #f8d7da; }
        .message { background: #fff3cd; padding: 5px; margin: 2px 0; font-size: 12px; }
    </style>
</head>
<body>
    <h1>ðŸŽ¬ SyncFlix - WebRTC Screen Sharing</h1>
    
    <div class="controls">
        <input type="text" id="roomId" placeholder="Room ID" value="test-room">
        <input type="text" id="username" placeholder="Your Name" value="User">
        <button onclick="connect()">Connect to Room</button>
        <button onclick="startScreenShare()" id="screenShareBtn">Start Screen Sharing</button>
        <button onclick="startCamera()" id="cameraBtn">Start Camera</button>
        <button onclick="disconnect()">Disconnect</button>
    </div>
    
    <div id="status" class="status disconnected">Disconnected</div>
    
    <div id="messages"></div>
    
    <h3>ðŸ‘¥ Users in Room:</h3>
    <div id="userList"></div>
    
    <div id="container">
        <div class="video-container">
            <h4>My Screen/Camera</h4>
            <video id="localVideo" autoplay muted playsinline></video>
            <div id="localInfo"></div>
        </div>
        <div id="remoteVideos"></div>
    </div>
    
    <script>
        // Configuration
        const SIGNALING_SERVER = 'wss://syncflix-r5ak.onrender.com';
        
        // Global variables
        let ws = null;
        let userId = null;
        let localStream = null;
        let peerConnections = {};
        let roomId = '';
        let username = '';
        
        // STUN/TURN servers (you should use your own for production)
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ]
        };
        
        // Connect to signaling server
        function connect() {
            roomId = document.getElementById('roomId').value.trim();
            username = document.getElementById('username').value.trim();
            
            if (!roomId) {
                alert('Please enter a room ID');
                return;
            }
            
            if (!username) {
                username = 'User' + Math.floor(Math.random() * 1000);
            }
            
            const wsUrl = `${SIGNALING_SERVER}/ws?room=${roomId}&username=${username}`;
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                updateStatus('âœ… Connected to signaling server', 'connected');
                logMessage('Connected to room: ' + roomId);
                
                // Send join message
                ws.send(JSON.stringify({
                    type: 'join',
                    timestamp: Date.now()
                }));
            };
            
            ws.onmessage = handleSignalingMessage;
            
            ws.onclose = () => {
                updateStatus('âŒ Disconnected from server', 'disconnected');
                logMessage('Disconnected');
                cleanup();
            };
            
            ws.onerror = (error) => {
                logMessage('WebSocket error: ' + error);
            };
        }
        
        // Handle signaling messages
        function handleSignalingMessage(event) {
            try {
                const data = JSON.parse(event.data);
                logMessage(`Received: ${data.type}`);
                
                switch(data.type) {
                    case 'welcome':
                        userId = data.userId;
                        updateStatus(`âœ… Connected as ${username} (ID: ${userId})`, 'connected');
                        logMessage(`Room: ${data.room}, Host: ${data.isHost ? 'Yes' : 'No'}`);
                        break;
                        
                    case 'existing-users':
                        logMessage(`Found ${data.users.length} existing user(s)`);
                        data.users.forEach(user => {
                            createPeerConnection(user.id, user.username);
                        });
                        updateUserList(data.users);
                        break;
                        
                    case 'user-joined':
                        logMessage(`ðŸ‘¤ ${data.username} joined the room`);
                        createPeerConnection(data.userId, data.username);
                        break;
                        
                    case 'user-left':
                        logMessage(`ðŸ‘‹ ${data.username} left the room`);
                        removePeerConnection(data.userId);
                        break;
                        
                    case 'offer':
                        handleOffer(data.sender, data.sdp, data.senderName);
                        break;
                        
                    case 'answer':
                        handleAnswer(data.sender, data.sdp);
                        break;
                        
                    case 'ice-candidate':
                        handleIceCandidate(data.sender, data.candidate);
                        break;
                        
                    case 'users-list':
                        updateUserList(data.users);
                        break;
                        
                    case 'error':
                        logMessage(`Error: ${data.message}`);
                        break;
                        
                    default:
                        logMessage(`Unknown message type: ${data.type}`);
                }
            } catch (error) {
                logMessage('Error parsing message: ' + error);
            }
        }
        
        // Start screen sharing
        async function startScreenShare() {
            try {
                // Stop existing stream
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                // Get screen share stream
                localStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: "always",
                        displaySurface: "monitor"
                    },
                    audio: false
                });
                
                // Show local screen
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
                document.getElementById('localInfo').innerHTML = 'ðŸ–¥ï¸ Screen Sharing Active';
                
                // Update all peer connections with new stream
                Object.keys(peerConnections).forEach(userId => {
                    updatePeerTracks(userId);
                });
                
                logMessage('âœ… Screen sharing started');
                document.getElementById('screenShareBtn').innerHTML = 'Stop Screen Sharing';
                document.getElementById('screenShareBtn').onclick = stopScreenShare;
                
                // Handle when user stops sharing via browser UI
                localStream.getVideoTracks()[0].onended = () => {
                    stopScreenShare();
                };
                
            } catch (error) {
                logMessage('âŒ Error starting screen share: ' + error.message);
            }
        }
        
        // Stop screen sharing
        function stopScreenShare() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = null;
                document.getElementById('localInfo').innerHTML = '';
                
                // Remove tracks from all peer connections
                Object.keys(peerConnections).forEach(userId => {
                    const pc = peerConnections[userId];
                    if (pc) {
                        const senders = pc.getSenders();
                        senders.forEach(sender => {
                            if (sender.track) {
                                pc.removeTrack(sender);
                            }
                        });
                    }
                });
                
                logMessage('ðŸ›‘ Screen sharing stopped');
                document.getElementById('screenShareBtn').innerHTML = 'Start Screen Sharing';
                document.getElementById('screenShareBtn').onclick = startScreenShare;
            }
        }
        
        // Start camera
        async function startCamera() {
            try {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                const localVideo = document.getElementById('localVideo');
                localVideo.srcObject = localStream;
                document.getElementById('localInfo').innerHTML = 'ðŸ“· Camera Active';
                
                // Update all peer connections
                Object.keys(peerConnections).forEach(userId => {
                    updatePeerTracks(userId);
                });
                
                logMessage('âœ… Camera started');
                
            } catch (error) {
                logMessage('âŒ Error starting camera: ' + error.message);
            }
        }
        
        // Create peer connection
        async function createPeerConnection(targetUserId, targetUsername) {
            if (peerConnections[targetUserId]) {
                logMessage(`Already connected to ${targetUsername}`);
                return;
            }
            
            logMessage(`Creating connection to ${targetUsername}`);
            
            try {
                // Create RTCPeerConnection
                const pc = new RTCPeerConnection(iceServers);
                peerConnections[targetUserId] = pc;
                
                // Add local stream if available
                if (localStream) {
                    updatePeerTracks(targetUserId);
                }
                
                // Handle ICE candidates
                pc.onicecandidate = (event) => {
                    if (event.candidate && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'ice-candidate',
                            target: targetUserId,
                            candidate: event.candidate,
                            timestamp: Date.now()
                        }));
                    }
                };
                
                // Handle remote stream
                pc.ontrack = (event) => {
                    logMessage(`ðŸ“¥ Received stream from ${targetUsername}`);
                    addRemoteVideo(targetUserId, targetUsername, event.streams[0]);
                };
                
                // Handle connection state
                pc.onconnectionstatechange = () => {
                    logMessage(`Connection state with ${targetUsername}: ${pc.connectionState}`);
                    if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                        removeRemoteVideo(targetUserId);
                    }
                };
                
                // Create and send offer
                const offer = await pc.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                
                await pc.setLocalDescription(offer);
                
                ws.send(JSON.stringify({
                    type: 'offer',
                    target: targetUserId,
                    sdp: offer,
                    timestamp: Date.now()
                }));
                
                logMessage(`ðŸ“¤ Sent offer to ${targetUsername}`);
                
            } catch (error) {
                logMessage(`âŒ Error creating peer connection: ${error.message}`);
                delete peerConnections[targetUserId];
            }
        }
        
        // Handle incoming offer
        async function handleOffer(senderId, sdp, senderName) {
            logMessage(`ðŸ“¥ Received offer from ${senderName}`);
            
            try {
                let pc = peerConnections[senderId];
                if (!pc) {
                    pc = new RTCPeerConnection(iceServers);
                    peerConnections[senderId] = pc;
                    
                    // Add local stream if available
                    if (localStream) {
                        updatePeerTracks(senderId);
                    }
                    
                    // Set up event handlers
                    pc.onicecandidate = (event) => {
                        if (event.candidate && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'ice-candidate',
                                target: senderId,
                                candidate: event.candidate,
                                timestamp: Date.now()
                            }));
                        }
                    };
                    
                    pc.ontrack = (event) => {
                        logMessage(`ðŸ“¥ Received stream from ${senderName}`);
                        addRemoteVideo(senderId, senderName, event.streams[0]);
                    };
                }
                
                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                
                // Create and send answer
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                
                ws.send(JSON.stringify({
                    type: 'answer',
                    target: senderId,
                    sdp: answer,
                    timestamp: Date.now()
                }));
                
                logMessage(`ðŸ“¤ Sent answer to ${senderName}`);
                
            } catch (error) {
                logMessage(`âŒ Error handling offer: ${error.message}`);
            }
        }
        
        // Handle answer
        async function handleAnswer(senderId, sdp) {
            logMessage(`ðŸ“¥ Received answer from ${senderId}`);
            
            const pc = peerConnections[senderId];
            if (pc) {
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                } catch (error) {
                    logMessage(`Error setting remote description: ${error.message}`);
                }
            }
        }
        
        // Handle ICE candidate
        async function handleIceCandidate(senderId, candidate) {
            logMessage(`ðŸ“¥ Received ICE candidate from ${senderId}`);
            
            const pc = peerConnections[senderId];
            if (pc) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (error) {
                    logMessage(`Error adding ICE candidate: ${error.message}`);
                }
            }
        }
        
        // Update peer tracks
        function updatePeerTracks(targetUserId) {
            const pc = peerConnections[targetUserId];
            if (!pc || !localStream) return;
            
            // Remove existing tracks
            const senders = pc.getSenders();
            senders.forEach(sender => {
                if (sender.track) {
                    pc.removeTrack(sender);
                }
            });
            
            // Add new tracks
            localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
            });
        }
        
        // Add remote video element
        function addRemoteVideo(userId, username, stream) {
            // Remove existing video if any
            const existingVideo = document.getElementById(`remote-video-${userId}`);
            if (existingVideo) {
                existingVideo.parentElement.remove();
            }
            
            // Create new video container
            const container = document.createElement('div');
            container.className = 'video-container';
            container.id = `remote-container-${userId}`;
            
            // Add title
            const title = document.createElement('h4');
            title.innerHTML = `ðŸ‘¤ ${username}`;
            container.appendChild(title);
            
            // Add video element
            const video = document.createElement('video');
            video.id = `remote-video-${userId}`;
            video.autoplay = true;
            video.playsinline = true;
            video.srcObject = stream;
            container.appendChild(video);
            
            // Add to DOM
            document.getElementById('remoteVideos').appendChild(container);
        }
        
        // Remove remote video
        function removeRemoteVideo(userId) {
            const container = document.getElementById(`remote-container-${userId}`);
            if (container) {
                container.remove();
            }
        }
        
        // Remove peer connection
        function removePeerConnection(userId) {
            const pc = peerConnections[userId];
            if (pc) {
                pc.close();
                delete peerConnections[userId];
            }
            removeRemoteVideo(userId);
        }
        
        // Update user list
        function updateUserList(users) {
            const userList = document.getElementById('userList');
            userList.innerHTML = '';
            
            users.forEach(user => {
                const div = document.createElement('div');
                div.innerHTML = `${user.username} ${user.isHost ? 'ðŸ‘‘' : ''} <small>(${user.id})</small>`;
                userList.appendChild(div);
            });
        }
        
        // Update status
        function updateStatus(message, className) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${className}`;
        }
        
        // Log message
        function logMessage(message) {
            const messagesDiv = document.getElementById('messages');
            const msgElement = document.createElement('div');
            msgElement.className = 'message';
            msgElement.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            messagesDiv.prepend(msgElement);
            
            // Keep only last 20 messages
            const allMessages = messagesDiv.getElementsByClassName('message');
            if (allMessages.length > 20) {
                messagesDiv.removeChild(allMessages[allMessages.length - 1]);
            }
        }
        
        // Cleanup
        function cleanup() {
            // Close all peer connections
            Object.keys(peerConnections).forEach(userId => {
                removePeerConnection(userId);
            });
            peerConnections = {};
            
            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Clear local video
            const localVideo = document.getElementById('localVideo');
            localVideo.srcObject = null;
            document.getElementById('localInfo').innerHTML = '';
            
            // Clear remote videos
            document.getElementById('remoteVideos').innerHTML = '';
            document.getElementById('userList').innerHTML = '';
            
            // Reset buttons
            document.getElementById('screenShareBtn').innerHTML = 'Start Screen Sharing';
            document.getElementById('screenShareBtn').onclick = startScreenShare;
        }
        
        // Disconnect
        function disconnect() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            cleanup();
            updateStatus('Disconnected', 'disconnected');
        }
        
        // Auto-connect on page load (optional)
        // window.addEventListener('load', () => {
        //     // Uncomment to auto-connect
        //     // connect();
        // });
    </script>
</body>
</html>